/**
 * Basic benchmark from the Savina benchmark suite that is intended to measure
 * message-passing overhead.
 *
 * This version is distributed, communicating using physical connections over
 * sockets.
 *
 * This is based on https://www.scala-lang.org/old/node/54 See
 * https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 *
 * This is a distributed version, where Ping and Pong run in separate programs
 * and can be run on different machines.
 *
 * To get a sense, some (informal) results for 1,000,000 ping-pongs on my Mac:
 * - Unthreaded: 97 msec
 * - Threaded: 265 msec
 * - Distributed: 53 seconds
 *
 * There is no parallelism in this application, so it does not benefit from
 * being being distributed.
 *
 * These measurements are total execution time, including startup and shutdown,
 * of all three programs.
 *
 * @author Edward A. Lee
 * @author Byeong-gil Jun
 */
target TypeScript

reactor Ping(count: number(10)) {
    input receive: number
    output send: number
    state pingsLeft: number(count)
    logical action serve

    reaction(startup, serve) -> send {=
        //printf("At logical time %lld, Ping sending %d.\n", lf_time_logical_elapsed(), self->pingsLeft);
        console.log(`At logical time ${util.getElapsedLogicalTime()}, Ping sending ${pingsLeft}.`);
        //lf_set(send, self->pingsLeft--);
        send = pingsLeft--;
    =}

    reaction(receive) -> serve {=
        // if (self->pingsLeft > 0) {
        //     lf_schedule(serve, 0);
        // } else {
        //     lf_request_stop();
        // }
        if (pingsLeft > 0) {
            actions.serve.schedule(0, null);
        } else {
            util.requestStop();
        }
    =}
}

reactor Pong(expected: number(10)) {
    input receive: number
    output send: number
    state count: number(0)

    reaction(receive) -> send {=
        //self->count++;
        count++;
        //printf("At logical time %lld, Pong received %d.\n", lf_time_logical_elapsed(), receive->value);
        console.log(`At logical time ${util.getElapsedLogicalTime()}, Pong receivedd ${receive}.`);
        //lf_set(send, receive->value);
        send = receive;
        // if (self->count == self->expected) {
        //     lf_request_stop();
        // }
        if (count === expected) {
            util.requestStop();
        }
    =}

    reaction(shutdown) {=
        // if (self->count != self->expected) {
        //     fprintf(stderr, "Pong expected to receive %d inputs, but it received %d.\n",
        //         self->expected, self->count
        //     );
        //     exit(1);
        // }
        if (count !== expected) {
            util.requestErrorStop(`Pong expected to received ${expected} inputs, but it received ${count}.`);
        }
        //printf("Pong received %d pings.\n", self->count);
        console.log(`Pong received ${count} pings.`);
    =}
}

federated reactor(count: number(10)) {
    ping = new Ping(count = count)
    pong = new Pong(expected = count)
    ping.send ~> pong.receive
    pong.send ~> ping.receive
}
