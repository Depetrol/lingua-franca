target C {
  timeout: 5 s
}

preamble {=
  #include "platform.h"
=}

// Produce a counting sequence starting with 1.
reactor Sense(period: time = 1 s) {
  state count: int = 1
  output out: int
  timer t(0, period)

  reaction(t) -> out {=
    lf_set(out, self->count++);
  =}
}

// Pass the input unchanged to the output, but take a long time to do it.
reactor Process {
  input in: int
  output out: int

  reaction(in) -> out {=
    lf_sleep(MSEC(35));
    lf_set(out, in->value);
  =}
}

// Report the inputs.
reactor Actuate {
  input in1: int
  input in2: int

  reaction(in1) {=
    printf(PRINTF_TIME ": Received on in1: %d\n", lf_time_logical_elapsed(), in1->value);
  =}

  reaction(in2) {=
    printf(PRINTF_TIME ": Received on in2: %d\n", lf_time_logical_elapsed(), in2->value);
  =} deadline(30 ms) {=
    printf(PRINTF_TIME ": Received on in2: %d", lf_time_logical_elapsed(), in2->value);
    printf("  *** PANIC! Deadline violated!\n");
  =}
}

federated reactor {
  s1 = new Sense()
  s2 = new Sense()
  c1 = new Process()
  a = new Actuate()
  s1.out -> c1.in
  c1.out -> a.in1 after 200 ms
  s2.out -> a.in2
}
