/**
 * Test watchdog. This test starts a watchdog timer of 150ms every 100ms. Half
 * the time, it then sleeps after starting the watchdog so that the watchdog
 * expires. There should be a total of five watchdog expirations.
 * @author Benjamin Asch
 * @author Edward A. Lee
 */
target C {
    timeout: 1100 ms
}

reactor Watcher(timeout: time = 150 ms) {
    timer t(100 ms, 100 ms)  // Offset ameliorates startup time.
    output d: int            // Produced if the watchdog triggers.
    state alternating: bool = false
    state count: int = 0

    watchdog poodle(timeout) {=
        instant_t p = lf_time_physical_elapsed() - lf_time_logical_elapsed();
        lf_print("Watchdog timed out! Lag: %lld (too late by " PRINTF_TIME " ns)", p, p - self->timeout);
        lf_print("At logical time inside watchdog panic: " PRINTF_TIME, lf_time_logical_elapsed());
        self->count++;
    =}

    reaction(t) -> poodle, d {=
        lf_watchdog_start(poodle, 0);
        lf_print("Watchdog started at physical time " PRINTF_TIME, lf_time_physical_elapsed());
        lf_print("Will expire at " PRINTF_TIME, lf_time_logical_elapsed() + self->timeout);
        if (self->alternating) {
            lf_sleep(MSEC(160));
        }
        self->alternating = !self->alternating;
    =}

    reaction(poodle) -> d {=
        lf_print("Reaction poodle was called.");
        lf_set(d, 1);
    =}

    reaction(shutdown) -> poodle {=
        lf_watchdog_stop(poodle);
        if (self->count != 5) {
            lf_print_error_and_exit("Watchdog expired %d times. Expected 5.", self->count);
        }
    =}
}

main reactor {
    logical action a
    state count: int = 0

    w = new Watcher()

    reaction(w.d) {=
        lf_print("*** Watcher reactor produced an output.");
        self->count++;
    =}

    reaction(shutdown) {=
        if (self->count != 5) {
            lf_print_error_and_exit("Watchdog produced output %d times. Expected 5.", self->count);
        }
    =}
}
