// Check for speedup of multithreaded execution on multicore machines. Each
// instance of TakeTime takes 200 ms to transport the input to the output. Four
// of them are instantiated. Note that without parallel execution, there is no
// way this can keep up with real time since in every 200 msec cycle it has 800
// msec of work to do. On a quad-core machine, however, it does pretty well,
// completing 800 msec of work in about 225 msec. See ThreadedMultiport for a
// parameterized version of this.
target C {
    timeout: 2 sec,
    tracing: true,
    // Disable compiler optimization so that TakeTime actually takes time.
    flags: ""
}

reactor Source {
    output out: int

    timer t(0, 200 msec)

    state s: int(0)

    reaction(t) -> out {=
        lf_set(out, self->s);
        self->s++;
    =}
}

reactor TakeTime {
    input in: int

    output out: int

    reaction(in) -> out {=
        // struct timespec sleep_time = {(time_t) 0, (long)200000000};
        // struct timespec remaining_time;
        // nanosleep(&sleep_time, &remaining_time);
        int offset = 0;
        for (int i = 0; i < 100000000; i++) {
            offset++;
        }
        lf_set(out, in->value + offset);
    =}
}

reactor Destination(width: int(4)) {
    input[width] in: int

    state s: int(400000000)

    reaction(in) {=
        int sum = 0;
        for (int i = 0; i < in_width; i++) {
            sum += in[i]->value;
        }
        printf("Sum of received: %d.\n", sum);
        if (sum != self->s) {
            printf("ERROR: Expected %d.\n", self->s);
            exit(1);
        }
        self->s += in_width;
    =}
}

main reactor ThreadedThreaded(width: int(4)) {
    a = new Source()
    t = new[width] TakeTime()
    b = new Destination(width = width)

    (a.out)+ -> t.in
    t.out -> b.in
}
