package org.lflang.generator.docker;

import java.util.List;
import org.lflang.LocalStrings;
import org.lflang.generator.LFGeneratorContext;
import org.lflang.generator.SubContext;
import org.lflang.generator.c.CCompiler;
import org.lflang.target.Target;

/**
 * Generate the docker file related code for the C and CCpp target.
 *
 * @author Hou Seng Wong
 */
public class CDockerGenerator extends DockerGenerator {

  /**
   * The constructor for the base docker file generation class.
   *
   * @param context The context of the code generator.
   */
  public CDockerGenerator(LFGeneratorContext context) {
    super(context);
  }

  public static final String DEFAULT_BASE_IMAGE = "alpine:latest";

  @Override
  public String defaultImage() {
    return DEFAULT_BASE_IMAGE;
  }

  /** Generate the contents of the docker file. */
  @Override
  protected String generateDockerFileContent() {
    var lfModuleName = context.getFileConfig().name;
    return String.join(
        "\n",
        "# Generated by the Lingua Franca compiler version " + LocalStrings.VERSION,
        "# - Docs: https://www.lf-lang.org/docs/handbook/containerized-execution",
        "",
        "FROM " + builderBase() + " AS builder",
        "WORKDIR /lingua-franca/" + lfModuleName,
        generateRunForInstallingDeps(),
        "COPY . src-gen",
        generateRunForBuild(),
        "",
        "FROM " + runnerBase(),
        "WORKDIR /lingua-franca",
        "RUN mkdir scripts",
        generateCopyOfScript(),
        "RUN mkdir bin",
        generateCopyOfExecutable(),
        generateEntryPoint(),
        "");
  }

  @Override
  public List<String> defaultEntryPoint() {
    if (context instanceof SubContext) {
      return List.of("./bin/" + context.getFileConfig().name, "-i", "1");
    } else {
      return List.of("./bin/" + context.getFileConfig().name);
    }
  }

  @Override
  protected String generateRunForInstallingDeps() {
    var config = context.getTargetConfig();
    var compiler = config.target == Target.CCPP ? "g++" : "gcc";
    if (builderBase().equals(defaultImage())) {
      return "RUN set -ex && apk add --no-cache %s musl-dev cmake make".formatted(compiler);
    } else {
      return "# (Skipping installation of build dependencies; custom base image.)";
    }
  }

  @Override
  protected List<String> defaultBuildCommands() {
    var ccompile =
        new CCompiler(
            context.getTargetConfig(),
            context.getFileConfig(),
            context.getErrorReporter(),
            context.getTargetConfig().target == Target.CCPP);

    return List.of(
        "mkdir -p bin",
        String.format(
            "%s -DCMAKE_INSTALL_BINDIR=./bin -S src-gen -B bin", ccompile.compileCmakeCommand()),
        "cd bin",
        "make all",
        "cd ..");
  }
}
